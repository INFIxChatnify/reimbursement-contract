const { expect } = require("chai");
const { ethers, upgrades } = require("hardhat");
const { loadFixture, time } = require("@nomicfoundation/hardhat-network-helpers");

describe("Vulnerability Test Suite", function () {
  async function deployFixture() {
    const [owner, admin, secretary, committee1, committee2, finance, director, attacker, user1, user2] = await ethers.getSigners();

    // Deploy OMTHB Token
    const OMTHBToken = await ethers.getContractFactory("OMTHBToken");
    const omthbToken = await upgrades.deployProxy(OMTHBToken, [owner.address], {
      initializer: 'initialize',
      kind: 'uups'
    });
    await omthbToken.waitForDeployment();

    // Mint tokens for testing
    await omthbToken.mint(owner.address, ethers.parseEther("1000000"));

    // Deploy MetaTxForwarder
    const MetaTxForwarder = await ethers.getContractFactory("MetaTxForwarder");
    const forwarder = await MetaTxForwarder.deploy();
    await forwarder.waitForDeployment();

    // Deploy ProjectReimbursement implementation
    const ProjectReimbursement = await ethers.getContractFactory("ProjectReimbursement");
    const projectImplementation = await ProjectReimbursement.deploy();
    await projectImplementation.waitForDeployment();

    // Deploy ProjectFactory
    const ProjectFactory = await ethers.getContractFactory("ProjectFactory");
    const factory = await ProjectFactory.deploy(
      await projectImplementation.getAddress(),
      await omthbToken.getAddress(),
      await forwarder.getAddress(),
      admin.address
    );
    await factory.waitForDeployment();

    // Setup roles
    await factory.connect(admin).grantRole(await factory.PROJECT_CREATOR_ROLE(), owner.address);

    // Create a test project
    const projectTx = await factory.connect(owner).createProject("TEST-001", ethers.parseEther("10000"), admin.address);
    const receipt = await projectTx.wait();
    const projectCreatedEvent = receipt.logs.find(log => {
      try {
        const parsed = factory.interface.parseLog(log);
        return parsed.name === "ProjectCreated";
      } catch (e) {
        return false;
      }
    });
    const parsedEvent = factory.interface.parseLog(projectCreatedEvent);
    const projectAddress = parsedEvent.args.projectContract;
    const project = await ethers.getContractAt("ProjectReimbursement", projectAddress);

    // Setup project roles
    await project.connect(admin).grantRole(await project.SECRETARY_ROLE(), secretary.address);
    await project.connect(admin).grantRole(await project.COMMITTEE_ROLE(), committee1.address);
    await project.connect(admin).grantRole(await project.COMMITTEE_ROLE(), committee2.address);
    await project.connect(admin).grantRole(await project.FINANCE_ROLE(), finance.address);
    await project.connect(admin).grantRole(await project.DIRECTOR_ROLE(), director.address);
    await project.connect(admin).grantRole(await project.REQUESTER_ROLE(), user1.address);

    // Transfer tokens to project
    await omthbToken.transfer(projectAddress, ethers.parseEther("10000"));

    // Deploy AuditAnchor
    const AuditAnchor = await ethers.getContractFactory("AuditAnchor");
    const auditAnchor = await AuditAnchor.deploy();
    await auditAnchor.waitForDeployment();

    return {
      omthbToken,
      forwarder,
      factory,
      project,
      projectImplementation,
      auditAnchor,
      owner,
      admin,
      secretary,
      committee1,
      committee2,
      finance,
      director,
      attacker,
      user1,
      user2
    };
  }

  describe("Critical Vulnerability Tests", function () {
    
    describe("CVE-001: Reentrancy in Fund Distribution", function () {
      it("Should prevent reentrancy attack during fund distribution", async function () {
        const { project, omthbToken, user1, secretary, committee1, finance, committee2, director, attacker } = await loadFixture(deployFixture);

        // Deploy malicious receiver contract
        const MaliciousReceiver = await ethers.getContractFactory("MaliciousContract");
        const maliciousContract = await MaliciousReceiver.deploy(await project.getAddress());
        await maliciousContract.waitForDeployment();

        // Create request with malicious contract as receiver
        const amount = ethers.parseEther("100");
        await project.connect(user1).createRequest(
          await maliciousContract.getAddress(),
          amount,
          "Test reimbursement",
          "QmTest"
        );

        // Go through approval flow - using commit-reveal
        // Secretary approval
        const secretaryNonce = 1;
        const secretaryCommitment = ethers.keccak256(ethers.solidityPacked(["address", "uint256", "uint256"], [secretary.address, 0, secretaryNonce]));
        await project.connect(secretary).commitApproval(0, secretaryCommitment);
        await time.increase(15 * 60 + 1); // Wait for reveal window
        await project.connect(secretary).approveBySecretary(0, secretaryNonce);
        
        // Committee approval
        const committee1Nonce = 2;
        const committee1Commitment = ethers.keccak256(ethers.solidityPacked(["address", "uint256", "uint256"], [committee1.address, 0, committee1Nonce]));
        await project.connect(committee1).commitApproval(0, committee1Commitment);
        await time.increase(15 * 60 + 1);
        await project.connect(committee1).approveByCommittee(0, committee1Nonce);
        
        // Finance approval
        const financeNonce = 3;
        const financeCommitment = ethers.keccak256(ethers.solidityPacked(["address", "uint256", "uint256"], [finance.address, 0, financeNonce]));
        await project.connect(finance).commitApproval(0, financeCommitment);
        await time.increase(15 * 60 + 1);
        await project.connect(finance).approveByFinance(0, financeNonce);
        
        // Committee additional approval
        const committee2Nonce = 4;
        const committee2Commitment = ethers.keccak256(ethers.solidityPacked(["address", "uint256", "uint256"], [committee2.address, 0, committee2Nonce]));
        await project.connect(committee2).commitApproval(0, committee2Commitment);
        await time.increase(15 * 60 + 1);
        await project.connect(committee2).approveByCommitteeAdditional(0, committee2Nonce);

        // Director approval should fail if reentrancy is attempted
        const balanceBefore = await omthbToken.balanceOf(await project.getAddress());
        
        // Director approval with commit-reveal
        const directorNonce = 5;
        const directorCommitment = ethers.keccak256(ethers.solidityPacked(["address", "uint256", "uint256"], [director.address, 0, directorNonce]));
        await project.connect(director).commitApproval(0, directorCommitment);
        await time.increase(15 * 60 + 1);
        
        // This should not allow reentrancy
        await project.connect(director).approveByDirector(0, directorNonce);
        
        const balanceAfter = await omthbToken.balanceOf(await project.getAddress());
        const transferred = balanceBefore - balanceAfter;
        
        // Should only transfer the approved amount once
        expect(transferred).to.equal(amount);
      });
    });

    describe("CVE-002: Unchecked External Call in Project Closure", function () {
      it("Should handle pause failure during project closure", async function () {
        const { factory, project, admin } = await loadFixture(deployFixture);

        // Add deputies
        const [deputy1, deputy2] = await ethers.getSigners();
        await factory.connect(admin).addDeputy(deputy1.address);
        await factory.connect(admin).addDeputy(deputy2.address);

        // Make project contract fail on pause (simulate by revoking admin role)
        await project.connect(admin).revokeRole(await project.DEFAULT_ADMIN_ROLE(), factory.address);

        // Initiate closure
        await factory.connect(deputy1).initiateProjectClosure("TEST-001");
        await factory.connect(deputy2).signClosureRequest("TEST-001");
        
        // Director sign should handle pause failure gracefully
        await expect(
          factory.connect(admin).signClosureRequest("TEST-001")
        ).to.be.reverted;
      });
    });

    describe("CVE-003: Front-Running in Approval Flow", function () {
      it("Should be vulnerable to approval front-running", async function () {
        const { project, user1, secretary, attacker } = await loadFixture(deployFixture);

        // Create a request
        await project.connect(user1).createRequest(
          user1.address,
          ethers.parseEther("100"),
          "Test",
          "QmTest"
        );

        // Attacker monitors mempool and sees secretary about to approve
        // In real scenario, attacker would front-run with higher gas
        
        // This demonstrates the vulnerability exists
        const request = await project.getRequest(0);
        expect(request.status).to.equal(0); // Pending
        
        // Secretary approves with commit-reveal
        const nonce = 1;
        const commitment = ethers.keccak256(ethers.solidityPacked(["address", "uint256", "uint256"], [secretary.address, 0, nonce]));
        await project.connect(secretary).commitApproval(0, commitment);
        await time.increase(15 * 60 + 1);
        await project.connect(secretary).approveBySecretary(0, nonce);
        
        // Vulnerability: Front-running protection now implemented via commit-reveal
        // This demonstrates the fix is in place
      });
    });
  });

  describe("High Severity Vulnerability Tests", function () {
    
    describe("CVE-004: DoS via Large Receiver Array", function () {
      it("Should handle gas limit attacks with large receiver arrays", async function () {
        const { project, user1 } = await loadFixture(deployFixture);

        // Create array with 101 receivers (above limit)
        const receivers = [];
        const amounts = [];
        for (let i = 0; i < 101; i++) {
          receivers.push(ethers.Wallet.createRandom().address);
          amounts.push(ethers.parseEther("1"));
        }

        // Should revert due to array size limit
        await expect(
          project.connect(user1).createRequest(receivers, amounts, "Large batch", "QmTest")
        ).to.be.reverted;
      });

      it("Should enforce gas validation for requests", async function () {
        const { project, user1 } = await loadFixture(deployFixture);

        // Create request with 50 receivers (at limit)
        const receivers = [];
        const amounts = [];
        for (let i = 0; i < 50; i++) {
          receivers.push(ethers.Wallet.createRandom().address);
          amounts.push(ethers.parseEther("1"));
        }

        // Set very low gas limit to trigger validation
        const lowGasLimit = 100000; // Too low for 50 transfers
        
        // Should fail due to insufficient gas
        await expect(
          project.connect(user1).createRequest(receivers, amounts, "Gas test", "QmTest", { gasLimit: lowGasLimit })
        ).to.be.reverted;
      });
    });

    describe("CVE-005: Weak Target Validation in MetaTxForwarder", function () {
      it("Should validate target contract type", async function () {
        const { forwarder, user1, attacker } = await loadFixture(deployFixture);

        // Deploy a malicious contract
        const MaliciousTarget = await ethers.getContractFactory("MaliciousContract");
        const maliciousTarget = await MaliciousTarget.deploy(await forwarder.getAddress());
        await maliciousTarget.waitForDeployment();

        const domain = {
          name: "MetaTxForwarder",
          version: "1",
          chainId: (await ethers.provider.getNetwork()).chainId,
          verifyingContract: await forwarder.getAddress()
        };

        const types = {
          ForwardRequest: [
            { name: "from", type: "address" },
            { name: "to", type: "address" },
            { name: "value", type: "uint256" },
            { name: "gas", type: "uint256" },
            { name: "nonce", type: "uint256" },
            { name: "deadline", type: "uint256" },
            { name: "data", type: "bytes" }
          ]
        };

        const request = {
          from: user1.address,
          to: await maliciousTarget.getAddress(),
          value: 0,
          gas: 100000,
          nonce: await forwarder.getNonce(user1.address),
          deadline: Math.floor(Date.now() / 1000) + 3600,
          data: "0x"
        };

        const signature = await user1.signTypedData(domain, types, request);

        // Current implementation allows any contract
        // This demonstrates the vulnerability
        await forwarder.execute(request, signature);
        
        // Recommendation: Implement whitelist
      });
    });

    describe("CVE-006: Storage Collision Risk", function () {
      it("Should have sufficient storage gap for upgrades", async function () {
        const { projectImplementation } = await loadFixture(deployFixture);

        // Check storage layout
        // This is a static analysis test
        // Recommendation: Use OpenZeppelin's upgrade plugin validations
        
        // Verify storage gap exists
        expect(true).to.be.true; // Placeholder - requires static analysis
      });
    });
  });

  describe("Medium Severity Vulnerability Tests", function () {
    
    describe("CVE-008: Timestamp Manipulation", function () {
      it("Should not rely on precise timestamps", async function () {
        const { project, user1 } = await loadFixture(deployFixture);

        // Create request
        await project.connect(user1).createRequest(
          user1.address,
          ethers.parseEther("100"),
          "Test",
          "QmTest"
        );

        const request = await project.getRequest(0);
        const createdAt = request.createdAt;

        // Timestamp can be manipulated by miners Â±15 seconds
        const currentTime = await time.latest();
        expect(createdAt).to.be.closeTo(currentTime, 20);
        
        // Vulnerability exists but impact is limited
      });
    });

    describe("CVE-009: Centralization Risk", function () {
      it("Should have single admin control", async function () {
        const { project, admin, attacker } = await loadFixture(deployFixture);

        // Admin can grant any role
        await project.connect(admin).grantRole(
          await project.DIRECTOR_ROLE(),
          attacker.address
        );

        // Admin can pause contract
        await project.connect(admin).pause();
        expect(await project.paused()).to.be.true;

        // Demonstrates centralization risk
        // Recommendation: Multi-sig or DAO governance
      });
    });

    describe("CVE-011: Sequential Nonce Issues", function () {
      it("Should handle parallel meta-transactions poorly", async function () {
        const { forwarder, user1 } = await loadFixture(deployFixture);

        const nonce1 = await forwarder.getNonce(user1.address);
        
        // In parallel execution, both transactions would use same nonce
        // Only one would succeed
        
        // This demonstrates the limitation
        expect(nonce1).to.equal(0);
        
        // Recommendation: 2D nonces like Permit
      });
    });
  });

  describe("Low Severity Vulnerability Tests", function () {
    
    describe("CVE-013: Missing Zero Address Validation", function () {
      it("Should validate zero addresses", async function () {
        const { factory, owner } = await loadFixture(deployFixture);

        // Some functions don't check address(0)
        await expect(
          factory.connect(owner).createProject(
            "TEST-002",
            ethers.parseEther("1000"),
            ethers.ZeroAddress // Should reject
          )
        ).to.be.revertedWith("InvalidAddress");
      });
    });

    describe("CVE-015: Unbounded Array Growth", function () {
      it("Should limit deputy array size", async function () {
        const { factory, admin } = await loadFixture(deployFixture);

        // Add many deputies
        const deputies = [];
        for (let i = 0; i < 10; i++) {
          const deputy = ethers.Wallet.createRandom();
          deputies.push(deputy);
          await factory.connect(admin).addDeputy(deputy.address);
        }

        // Get all deputies - could fail with too many
        const allDeputies = await factory.getDeputies();
        expect(allDeputies.length).to.equal(10);
        
        // Recommendation: Implement pagination or limits
      });
    });

    describe("CVE-016: Inconsistent Pause Implementation", function () {
      it("Should check pause state in all functions", async function () {
        const { project, admin, user1 } = await loadFixture(deployFixture);

        // Pause contract
        await project.connect(admin).pause();

        // All state-changing functions should revert
        await expect(
          project.connect(user1).createRequest(
            user1.address,
            ethers.parseEther("100"),
            "Test",
            "QmTest"
          )
        ).to.be.revertedWith("Pausable: paused");
      });
    });
  });

  describe("Gas Optimization Tests", function () {
    
    it("Should optimize struct packing", async function () {
      // This is a static analysis test
      // Structs should pack variables efficiently
      // e.g., group uint256 together, then addresses, then smaller types
      
      // Recommendation: Reorder struct members
      expect(true).to.be.true; // Placeholder
    });

    it("Should use custom errors for gas efficiency", async function () {
      const { project, attacker } = await loadFixture(deployFixture);

      // Custom errors use less gas than require strings
      await expect(
        project.connect(attacker).approveBySecretary(0, 1)
      ).to.be.reverted;
      
      // Should use custom error instead of string
    });
  });

  describe("Exploit Scenario Tests", function () {
    
    it("Complete attack scenario: Drain project funds", async function () {
      const { project, omthbToken, user1, secretary, committee1, finance, committee2, director, attacker } = await loadFixture(deployFixture);

      // Scenario: Attacker gains control of one role and exploits vulnerabilities
      
      // Step 1: Create legitimate looking request
      const attackAmount = ethers.parseEther("5000");
      await project.connect(user1).createRequest(
        attacker.address,
        attackAmount,
        "Legitimate expense",
        "QmLegitimate"
      );

      // Step 2: If attacker compromised secretary account
      // They could front-run other approvals
      
      // Normal approval flow with commit-reveal
      // Secretary
      const secNonce = 1;
      const secCommit = ethers.keccak256(ethers.solidityPacked(["address", "uint256", "uint256"], [secretary.address, 0, secNonce]));
      await project.connect(secretary).commitApproval(0, secCommit);
      await time.increase(15 * 60 + 1);
      await project.connect(secretary).approveBySecretary(0, secNonce);
      
      // Committee
      const com1Nonce = 2;
      const com1Commit = ethers.keccak256(ethers.solidityPacked(["address", "uint256", "uint256"], [committee1.address, 0, com1Nonce]));
      await project.connect(committee1).commitApproval(0, com1Commit);
      await time.increase(15 * 60 + 1);
      await project.connect(committee1).approveByCommittee(0, com1Nonce);
      
      // Finance
      const finNonce = 3;
      const finCommit = ethers.keccak256(ethers.solidityPacked(["address", "uint256", "uint256"], [finance.address, 0, finNonce]));
      await project.connect(finance).commitApproval(0, finCommit);
      await time.increase(15 * 60 + 1);
      await project.connect(finance).approveByFinance(0, finNonce);
      
      // Committee Additional
      const com2Nonce = 4;
      const com2Commit = ethers.keccak256(ethers.solidityPacked(["address", "uint256", "uint256"], [committee2.address, 0, com2Nonce]));
      await project.connect(committee2).commitApproval(0, com2Commit);
      await time.increase(15 * 60 + 1);
      await project.connect(committee2).approveByCommitteeAdditional(0, com2Nonce);
      
      // Director
      const dirNonce = 5;
      const dirCommit = ethers.keccak256(ethers.solidityPacked(["address", "uint256", "uint256"], [director.address, 0, dirNonce]));
      await project.connect(director).commitApproval(0, dirCommit);
      await time.increase(15 * 60 + 1);
      await project.connect(director).approveByDirector(0, dirNonce);

      // Funds distributed
      expect(await omthbToken.balanceOf(attacker.address)).to.equal(attackAmount);
      
      // Demonstrates need for:
      // 1. Multi-sig approvals
      // 2. Time delays
      // 3. Withdrawal limits
    });

    it("Meta-transaction replay attack", async function () {
      const { forwarder, user1 } = await loadFixture(deployFixture);

      const domain = {
        name: "MetaTxForwarder",
        version: "1",
        chainId: (await ethers.provider.getNetwork()).chainId,
        verifyingContract: await forwarder.getAddress()
      };

      const types = {
        ForwardRequest: [
          { name: "from", type: "address" },
          { name: "to", type: "address" },
          { name: "value", type: "uint256" },
          { name: "gas", type: "uint256" },
          { name: "nonce", type: "uint256" },
          { name: "deadline", type: "uint256" },
          { name: "data", type: "bytes" }
        ]
      };

      const request = {
        from: user1.address,
        to: await forwarder.getAddress(),
        value: 0,
        gas: 100000,
        nonce: await forwarder.getNonce(user1.address),
        deadline: Math.floor(Date.now() / 1000) + 3600,
        data: "0x"
      };

      const signature = await user1.signTypedData(domain, types, request);

      // Execute once
      await forwarder.execute(request, signature);

      // Try replay - should fail due to nonce
      await expect(
        forwarder.execute(request, signature)
      ).to.be.revertedWithCustomError(forwarder, "InvalidNonce");
      
      // Protection works correctly
    });
  });
});